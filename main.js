const prompt = require('prompt-sync')({ sigint: true });

const hat = '^';
const hole = 'O';
const fieldCharacter = 'â–‘';
const pathCharacter = '*';

let fieldIsValid = false;

class Field {
    /**
     * @param {Array<Array<String>> | true} arr2D "true" for auto generated field
     * @param {number} [area=10] To determine the width and height for the autogenerated field
     */
    constructor(arr2D, area = 10) {
        this.field = arr2D == true ? Field.generateField(area) : arr2D;
        this.nonPlayers = [];
        this.player = this.findPlayer();
    }

    /**
     * @param {number} area 
     * @returns {Array<Array<String>>}
     */
    static generateField(area) {
        let holesToPlace = Math.round(area * 0.4);

        let field = [];
        for (let i = 0; i < area; i++) {
            field[i] = [];

            //#region Placing holes

            const holes = [];
            let holesPlaced = 0;
            while (holes.length < holesToPlace) {
                let num = Math.floor(Math.random() * area);
                if (holes.indexOf(num) == -1) {
                    holes.push(num);
                }
            }

            //#endregion

            for (let j = 0; j < area; j++) {
                if (holesPlaced < holesToPlace
                    && holes.indexOf(j) > -1) {
                    holesPlaced++;
                    field[i][j] = hole;
                } else {
                    field[i][j] = fieldCharacter;
                }
            }
        }

        // Path character
        const pathPlayer = [Math.floor(Math.random() * 2), Math.floor(Math.random() * area)]
        field[pathPlayer[0]][pathPlayer[1]] = pathCharacter;

        //#region Placing hat

        let isActive = true;
        while (isActive == true) {
            let nums = [Math.floor(Math.random() * area - 2) + 2, Math.floor(Math.random() * area)]
            if (nums[0] != pathPlayer[0]
                && nums[1] != pathPlayer[1]) {
                field[nums[0]][nums[1]] = hat;
                isActive = false;
            }
        }

        //#endregion

        const fieldClone = field.map(arr => arr.slice(0));
        const isValid = this.validateField(fieldClone);
        if (!isValid) {
            return this.generateField(area);
        }
        return field;
    }

    /**
     * @param {Array<Array<String>>} fieldGen 
     * @returns {Boolean}
     */
    static validateField(fieldGen) {
        this._fieldValidator(new Field(fieldGen));
        if (fieldIsValid == true) {
            fieldIsValid = false;
            return true;
        } else {
            return false;
        }
    }

    /**
     * 
     * @param {Field} field 
     * @param {String} [direction ]
     */
    static _fieldValidator(field, direction) {
        if (direction) {
            field[direction]();
        }
        let thisIDPlayer = Object.assign([], field.player);

        if ((upCheck() !== "win" && upCheck() !== "true")
            && (downCheck() !== "win" && downCheck() !== "true")
            && (leftCheck() !== "win" && leftCheck() !== "true")
            && (rightCheck() !== "win" && rightCheck() !== "true")) {
            return;
        }

        if (upCheck() === "win"
            || downCheck() === "win"
            || leftCheck() === "win"
            || rightCheck() === "win") {
            fieldIsValid = true;
            return;
        }

        if (upCheck() === "true") {
            this._fieldValidator(field, "up");
        }
        field.updatePlayer(thisIDPlayer[0], thisIDPlayer[1]);
        if (downCheck() === "true") {
            this._fieldValidator(field, "down");
        }
        field.updatePlayer(thisIDPlayer[0], thisIDPlayer[1]);
        if (leftCheck() === "true") {
            this._fieldValidator(field, "left");
        }
        field.updatePlayer(thisIDPlayer[0], thisIDPlayer[1]);
        if (rightCheck() === "true") {
            this._fieldValidator(field, "right");
        }
        field.updatePlayer(thisIDPlayer[0], thisIDPlayer[1]);

        function upCheck() {
            return field.checkNext(thisIDPlayer[0] - 1, thisIDPlayer[1]);
        }

        function downCheck() {
            return field.checkNext(thisIDPlayer[0] + 1, thisIDPlayer[1]);
        }

        function leftCheck() {
            return field.checkNext(thisIDPlayer[0], thisIDPlayer[1] - 1);
        }

        function rightCheck() {
            return field.checkNext(thisIDPlayer[0], thisIDPlayer[1] + 1);
        }
    }

    clear() {
        try {
            console.clear();
        } catch (err) {
            console.log("\n".repeat(25));
        }
    }

    print() {
        this.field.forEach(ele => {
            console.log(ele.join(""));
        });
    }

    findPlayer() {
        let activeRow = [this.field[0], 0];
        let activeColumn = [activeRow[0][0], 0];
        for (let i = 0; i < this.field.length; i++) {
            activeColumn = [activeRow[0][0], 0];
            for (let j = 0; j < this.field[i].length; j++) {
                if (activeColumn[0] === pathCharacter
                    && !this.nonPlayers.find(arr => arr[0] === activeRow[1] && arr[1] === activeColumn[1])) {
                    return [activeRow[1], activeColumn[1]];
                } else {
                    activeColumn = [activeRow[0][j + 1], j + 1];
                }
            }
            activeRow = [this.field[i + 1], i + 1];
        }
        return false;
    }

    updatePlayer(posX, posY) {
        this.nonPlayers.push(this.player);
        this.player = [posX, posY];
    }

    processMove(choice) {
        switch (choice.toLowerCase()) {
            case "u": {
                return this.up();
            }
            case "d": {
                return this.down();
            }
            case "l": {
                return this.left();
            }
            case "r": {
                return this.right();
            }
            default: {
                return "invalid";
            }
        }
    }

    checkNext(posX, posY) {
        try {
            const movePos = this.field[posX][posY];
            if (movePos == undefined) {
                return "outofbounds";
            }
            if (movePos === hole) {
                return "lose";
            }
            if (movePos === hat) {
                return "win";
            }
            if (movePos === pathCharacter) {
                return "player";
            }
            if (movePos === fieldCharacter) {
                return "true";
            }
        } catch (err) {
            return "outofbounds";
        }
    }

    moveCharacter(posX, posY) {
        this.field[posX][posY] = pathCharacter;
    }

    move(posX, posY) {
        const validate = this.checkNext(posX, posY);
        switch (validate) {
            case "true": {
                this.moveCharacter(posX, posY);
                this.updatePlayer(posX, posY);
            }
            default: {
                return validate;
            }
        }
    }

    up() {
        return this.move(this.player[0] - 1, this.player[1]);
    }

    down() {
        return this.move(this.player[0] + 1, this.player[1]);
    }

    left() {
        return this.move(this.player[0], this.player[1] - 1);
    }

    right() {
        return this.move(this.player[0], this.player[1] + 1);
    }
}

/**
 * new Field(true, 3) EASY MODE
 * 
 * new Field(true, 10) NORMAL MODE
 * 
 * new Field(true, 50) HARD MODE
 * 
 */
const field = new Field(true, 50);

let gameIsActive = true;
let previousWasInvalid = false;
while (gameIsActive == true) {
    field.clear(); // Clear and print fields on prompt finish
    field.print();

    if (previousWasInvalid == true) {
        previousWasInvalid = false;
        console.log("Invalid move, try again");
    }
    const userPrompt = field.processMove(prompt("Where do you want to move (U, D, L, R)? "));
    if (userPrompt != "true") {
        switch (userPrompt) {
            case "outofbounds": {
                console.log("You've left the bounds of the game!");
                gameIsActive = false;
                break;
            }
            case "lose": {
                console.log("Oh no! You've hit a hole. Game over!");
                gameIsActive = false;
                break;
            }
            case "invalid": {
                previousWasInvalid = true;
                break;
            }
            case "player": {
                console.log("You ran over yourself! Game over!");
                gameIsActive = false;
                break;
            }
            case "win": {
                console.log("You made it to the hat! You win!");
                gameIsActive = false;
                break;
            }
        }
    }
}